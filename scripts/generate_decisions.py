#!/usr/bin/env python3
"""
Generate DECISIONS.md - a comprehensive map of all section connections.
Shows which sections lead to each section (incoming) and which sections each section points to (outgoing).
"""

import yaml
from pathlib import Path
from collections import defaultdict

def parse_frontmatter(content):
    """Extract YAML frontmatter from markdown file."""
    if not content.startswith('---'):
        return None, content
    
    parts = content.split('---', 2)
    if len(parts) < 3:
        return None, content
    
    try:
        frontmatter = yaml.safe_load(parts[1])
        return frontmatter, parts[2]
    except yaml.YAMLError:
        return None, content

def scan_sections(sections_dir='src/content/sections'):
    """Scan all section files and build connection maps."""
    sections_path = Path(sections_dir)
    
    if not sections_path.exists():
        print(f"Error: {sections_dir} directory not found!")
        return {}, {}, {}
    
    # Get all section files
    section_files = sorted(sections_path.glob('section-*.md'))
    
    print(f"Scanning {len(section_files)} section files...")
    
    # Store section metadata
    sections_info = {}
    
    # Forward map: section -> list of sections it points to (with choice info)
    outgoing_map = defaultdict(list)
    
    # Reverse map: section -> list of sections that point to it (with choice info)
    incoming_map = defaultdict(list)
    
    for md_file in section_files:
        try:
            with open(md_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            frontmatter, body = parse_frontmatter(content)
            if not frontmatter:
                continue
            
            section_id = frontmatter.get('id', '')
            title = frontmatter.get('title', 'Untitled')
            choices = frontmatter.get('choices', [])
            
            # Store section info
            sections_info[md_file.name] = {
                'id': section_id,
                'title': title,
                'filename': md_file.name
            }
            
            # Build outgoing map (sections this section points to)
            for choice in choices:
                target = choice.get('target', '')
                choice_text = choice.get('text', '')
                
                if target:
                    outgoing_map[md_file.name].append({
                        'target': target,
                        'text': choice_text
                    })
                    
                    # Build incoming map (sections that point to this target)
                    incoming_map[target].append({
                        'source': md_file.name,
                        'text': choice_text
                    })
        
        except Exception as e:
            print(f"Error processing {md_file.name}: {e}")
            continue
    
    return sections_info, outgoing_map, incoming_map

def generate_decisions_md(sections_info, outgoing_map, incoming_map, output_file='DECISIONS.md'):
    """Generate DECISIONS.md with incoming and outgoing links for each section."""
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Decisions Map\n\n")
        f.write("This file provides a comprehensive map of all section connections in the adventure.\n")
        f.write("It shows which sections lead to each section (incoming links) and which sections each section points to (outgoing links).\n\n")
        f.write("**Note:** This file is automatically generated. Do not edit manually.\n\n")
        f.write("---\n\n")
        
        # Get all unique section filenames and sort them
        all_sections = set(sections_info.keys())
        all_sections.update(outgoing_map.keys())
        all_sections.update(incoming_map.keys())
        sorted_sections = sorted(all_sections)
        
        # Section 1: Incoming Links
        f.write("## Incoming Links\n\n")
        f.write("For each section, this shows which sections lead to it.\n\n")
        
        for section_file in sorted_sections:
            section = sections_info.get(section_file, {})
            section_id = section.get('id', section_file.replace('.md', ''))
            section_title = section.get('title', 'Untitled')
            
            incoming = incoming_map.get(section_file, [])
            
            f.write(f"### {section_file}\n\n")
            f.write(f"**ID:** `{section_id}`  \n")
            f.write(f"**Title:** {section_title}\n\n")
            
            if incoming:
                f.write("**Referenced by:**\n")
                for link in sorted(incoming, key=lambda x: x['source']):
                    f.write(f"- `{link['source']}` (choice: \"{link['text']}\")\n")
            else:
                f.write("**Referenced by:** *No incoming links*\n")
            
            f.write("\n")
        
        f.write("---\n\n")
        
        # Section 2: Outgoing Links
        f.write("## Outgoing Links\n\n")
        f.write("For each section, this shows which sections it points to.\n\n")
        
        for section_file in sorted_sections:
            section = sections_info.get(section_file, {})
            section_id = section.get('id', section_file.replace('.md', ''))
            section_title = section.get('title', 'Untitled')
            
            outgoing = outgoing_map.get(section_file, [])
            
            f.write(f"### {section_file}\n\n")
            f.write(f"**ID:** `{section_id}`  \n")
            f.write(f"**Title:** {section_title}\n\n")
            
            if outgoing:
                f.write("**Points to:**\n")
                for link in sorted(outgoing, key=lambda x: x['target']):
                    f.write(f"- `{link['target']}` (choice: \"{link['text']}\")\n")
            else:
                f.write("**Points to:** *No outgoing links (terminated)*\n")
            
            f.write("\n")
        
        f.write("---\n\n")
        
        # Summary
        f.write("## Summary\n\n")
        f.write(f"Total sections: **{len(sorted_sections)}**\n\n")
        
        sections_with_incoming = len([s for s in sorted_sections if incoming_map.get(s)])
        sections_with_outgoing = len([s for s in sorted_sections if outgoing_map.get(s)])
        terminated_sections = len([s for s in sorted_sections if not outgoing_map.get(s)])
        
        f.write(f"- Sections with incoming links: **{sections_with_incoming}**\n")
        f.write(f"- Sections with outgoing links: **{sections_with_outgoing}**\n")
        f.write(f"- Terminated sections (no outgoing links): **{terminated_sections}**\n")
        f.write(f"- Sections with no incoming links: **{len(sorted_sections) - sections_with_incoming}**\n")

if __name__ == '__main__':
    import sys
    
    sections_dir = sys.argv[1] if len(sys.argv) > 1 else 'src/content/sections'
    output_file = sys.argv[2] if len(sys.argv) > 2 else 'DECISIONS.md'
    
    print("Starting decisions map generation...")
    sections_info, outgoing_map, incoming_map = scan_sections(sections_dir)
    
    print(f"\nFound {len(sections_info)} sections")
    print(f"  - {len(outgoing_map)} sections with outgoing links")
    print(f"  - {len(incoming_map)} sections with incoming links")
    
    print(f"\nGenerating report: {output_file}")
    generate_decisions_md(sections_info, outgoing_map, incoming_map, output_file)
    
    print("\nGeneration complete!")

